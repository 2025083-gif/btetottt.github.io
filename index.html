<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tetris: Ultimate ver.</title>
  <style>
    :root {
      --bg-color: #1a1a20;
      --panel-color: #2a2a35;
      --accent-color: #00d8ff;
      --text-color: #eee;
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none; /* スマホでのスクロール防止 */
    }

    /* ゲームレイアウト */
    .main-container {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }

    .game-wrapper {
      position: relative;
      border: 4px solid var(--panel-color);
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    canvas#tetris {
      display: block;
      background-color: #000;
    }

    /* サイドパネル（スコア・NEXT） */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 100px;
    }

    .panel {
      background: var(--panel-color);
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }

    .label { font-size: 11px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; }
    .value { font-size: 20px; font-weight: bold; color: var(--accent-color); }

    canvas#next {
      background: #000;
      width: 80px;
      height: 80px;
      margin: 0 auto;
      border: 1px solid #444;
    }

    /* オーバーレイ（スタート・ゲームオーバー） */
    .overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    
    .overlay.hidden { display: none; }

    .btn {
      background: var(--accent-color);
      color: #000;
      border: none;
      padding: 10px 30px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 20px;
      margin-top: 15px;
      transition: transform 0.1s;
    }
    .btn:active { transform: scale(0.95); }

    h1 { margin: 0 0 10px; color: var(--accent-color); text-transform: uppercase; font-size: 24px; }
    p { margin: 5px 0; font-size: 14px; color: #ccc; }

    /* スマホ用コントローラー */
    .mobile-controls {
      margin-top: 20px;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 50px 50px;
      gap: 10px;
    }
    
    .c-btn {
      background: var(--panel-color);
      border: 1px solid #555;
      color: #fff;
      border-radius: 8px;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
    }
    .c-btn:active { background: #444; }
    
    /* グリッド配置 */
    .c-left { grid-column: 1; grid-row: 2; }
    .c-down { grid-column: 2; grid-row: 2; }
    .c-right { grid-column: 3; grid-row: 2; }
    .c-rot { grid-column: 2; grid-row: 1; background: #3a3a45; }
    .c-pause { grid-column: 3; grid-row: 1; font-size: 12px; }

    /* PCではコントローラーを隠す（画面幅が狭い時だけ表示でも良いが今回は常時表示） */
    @media (min-width: 800px) {
      .mobile-controls { display: none; }
    }
  </style>
</head>
<body>

  <div class="main-container">
    <div class="game-wrapper">
      <canvas id="tetris" width="240" height="400"></canvas>
      
      <div id="start-screen" class="overlay">
        <h1>Tetris</h1>
        <p>Bomb & Giant Edition</p>
        <button class="btn" onclick="game.start()">START</button>
      </div>

      <div id="gameover-screen" class="overlay hidden">
        <h1 style="color:#ff4444">GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button class="btn" onclick="game.reset()">RETRY</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
        <h1>PAUSED</h1>
        <button class="btn" onclick="game.togglePause()">RESUME</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <div class="label">Next</div>
        <canvas id="next" width="80" height="80"></canvas>
      </div>
      <div class="panel">
        <div class="label">Score</div>
        <div class="value" id="score">0</div>
      </div>
      <div class="panel">
        <div class="label">Level</div>
        <div class="value" id="level">1</div>
      </div>
      <div class="panel" style="font-size:10px; text-align:left;">
        <span style="color:#ff4444">■</span> Bomb<br>
        <span style="color:#78909c">■</span> Giant
      </div>
    </div>
  </div>

  <div class="mobile-controls">
    <div class="c-btn c-rot" ontouchstart="game.input(38); event.preventDefault()" onmousedown="game.input(38)">↻</div>
    <div class="c-btn c-pause" ontouchstart="game.togglePause(); event.preventDefault()" onmousedown="game.togglePause()">II</div>
    <div class="c-btn c-left" ontouchstart="game.input(37); event.preventDefault()" onmousedown="game.input(37)">←</div>
    <div class="c-btn c-down" ontouchstart="game.input(40); event.preventDefault()" onmousedown="game.input(40)">↓</div>
    <div class="c-btn c-right" ontouchstart="game.input(39); event.preventDefault()" onmousedown="game.input(39)">→</div>
  </div>

<script>
/* 定数・設定 */
const COLS = 12;
const ROWS = 20;
const BLOCK_SIZE = 20;

const PIECES = {
  'T': { shape: [[0, 1, 0],[1, 1, 1],[0, 0, 0]], id: 1 },
  'O': { shape: [[2, 2],[2, 2]], id: 2 },
  'L': { shape: [[0, 3, 0],[0, 3, 0],[0, 3, 3]], id: 3 },
  'J': { shape: [[0, 4, 0],[0, 4, 0],[4, 4, 0]], id: 4 },
  'I': { shape: [[0, 5, 0, 0],[0, 5, 0, 0],[0, 5, 0, 0],[0, 5, 0, 0]], id: 5 },
  'S': { shape: [[0, 6, 6],[6, 6, 0],[0, 0, 0]], id: 6 },
  'Z': { shape: [[7, 7, 0],[0, 7, 7],[0, 0, 0]], id: 7 },
  'B': { shape: [[8]], id: 8 }, // Bomb
  'G': { shape: [[9, 9, 9],[9, 9, 9],[9, 9, 9]], id: 9 }, // Giant
};

const COLORS = [
  null,
  '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF',
  '#FF0000', // Bomb
  '#78909C'  // Giant
];

/* ユーティリティ */
function createMatrix(w, h) {
  const matrix = [];
  while (h--) matrix.push(new Array(w).fill(0));
  return matrix;
}

function collide(arena, player) {
  const [m, o] = [player.matrix, player.pos];
  for (let y = 0; y < m.length; ++y) {
    for (let x = 0; x < m[y].length; ++x) {
      if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
        return true;
      }
    }
  }
  return false;
}

function rotate(matrix, dir) {
  for (let y = 0; y < matrix.length; ++y) {
    for (let x = 0; x < y; ++x) {
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if (dir > 0) matrix.forEach(row => row.reverse());
  else matrix.reverse();
}

/* ゲームクラス */
class Tetris {
  constructor() {
    this.canvas = document.getElementById('tetris');
    this.context = this.canvas.getContext('2d');
    this.context.scale(BLOCK_SIZE, BLOCK_SIZE);

    this.nextCanvas = document.getElementById('next');
    this.nextContext = this.nextCanvas.getContext('2d');
    this.nextContext.scale(BLOCK_SIZE, BLOCK_SIZE);

    this.arena = createMatrix(COLS, ROWS);
    
    this.player = {
      pos: {x: 0, y: 0},
      matrix: null,
      score: 0,
      level: 1
    };

    this.nextPiece = null; // NEXTブロック保持用
    
    this.dropCounter = 0;
    this.dropInterval = 1000;
    this.lastTime = 0;
    
    this.isRunning = false;
    this.isPaused = false;
    this.requestId = null;

    // キー入力
    document.addEventListener('keydown', event => this.handleKey(event));
  }

  // ブロック生成
  getPiece() {
    const types = 'ILJOTSZBG';
    const type = types[types.length * Math.random() | 0];
    // コピーして返す
    return PIECES[type].shape.map(row => [...row]);
  }

  // ゲーム開始
  start() {
    document.getElementById('start-screen').classList.add('hidden');
    this.resetGame();
    this.isRunning = true;
    this.update();
  }

  // リセット
  reset() {
    document.getElementById('gameover-screen').classList.add('hidden');
    this.resetGame();
    this.isRunning = true;
    this.update();
  }

  resetGame() {
    this.arena.forEach(row => row.fill(0));
    this.player.score = 0;
    this.player.level = 1;
    this.dropInterval = 1000;
    this.updateScore();
    
    // 最初のセットアップ
    this.nextPiece = this.getPiece(); 
    this.playerReset();
  }

  playerReset() {
    this.player.matrix = this.nextPiece; // NEXTを現在へ
    this.nextPiece = this.getPiece();    // 新しいNEXT生成
    
    this.player.pos.y = 0;
    this.player.pos.x = (this.arena[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);

    // 出現即衝突ならゲームオーバー
    if (collide(this.arena, this.player)) {
      this.isRunning = false;
      document.getElementById('final-score').innerText = this.player.score;
      document.getElementById('gameover-screen').classList.remove('hidden');
    }
    
    // NEXT描画更新
    this.drawNext();
  }

  playerDrop() {
    this.player.pos.y++;
    if (collide(this.arena, this.player)) {
      this.player.pos.y--;
      
      // 爆弾(8)チェック
      const isBomb = this.player.matrix.some(r => r.includes(8));
      if (isBomb) {
        this.explode();
      } else {
        this.merge(this.arena, this.player);
      }
      
      this.playerReset();
      this.arenaSweep();
      this.dropCounter = 0;
    }
    this.dropCounter = 0;
  }

  input(keyCode) {
    if (!this.isRunning || this.isPaused) return;
    
    if (keyCode === 37) { // Left
      this.player.pos.x--;
      if (collide(this.arena, this.player)) this.player.pos.x++;
    } else if (keyCode === 39) { // Right
      this.player.pos.x++;
      if (collide(this.arena, this.player)) this.player.pos.x--;
    } else if (keyCode === 40) { // Down
      this.playerDrop();
    } else if (keyCode === 38) { // Rotate
      this.playerRotate(1);
    }
  }
  
  handleKey(event) {
    if (event.keyCode === 80) { // 'P'
      this.togglePause();
      return;
    }
    this.input(event.keyCode);
  }

  playerRotate(dir) {
    const pos = this.player.pos.x;
    let offset = 1;
    rotate(this.player.matrix, dir);
    while (collide(this.arena, this.player)) {
      this.player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > this.player.matrix[0].length) {
        rotate(this.player.matrix, -dir);
        this.player.pos.x = pos;
        return;
      }
    }
  }

  merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  explode() {
    const r = 2; // 爆発半径
    const cx = this.player.pos.x + 1;
    const cy = this.player.pos.y + 1;
    for (let y = cy - r; y <= cy + r; y++) {
      for (let x = cx - r; x <= cx + r; x++) {
        if (y >= 0 && y < this.arena.length && x >= 0 && x < this.arena[0].length) {
          this.arena[y][x] = 0;
        }
      }
    }
  }

  arenaSweep() {
    let rowCount = 0;
    outer: for (let y = this.arena.length - 1; y > 0; --y) {
      for (let x = 0; x < this.arena[y].length; ++x) {
        if (this.arena[y][x] === 0) continue outer;
      }
      const row = this.arena.splice(y, 1)[0].fill(0);
      this.arena.unshift(row);
      ++y;
      rowCount++;
    }
    if (rowCount > 0) {
      this.player.score += rowCount * 10 * rowCount;
      this.player.level = Math.floor(this.player.score / 200) + 1;
      this.dropInterval = Math.max(100, 1000 - (this.player.level * 50));
      this.updateScore();
    }
  }

  updateScore() {
    document.getElementById('score').innerText = this.player.score;
    document.getElementById('level').innerText = this.player.level;
  }

  togglePause() {
    if (!this.isRunning) return;
    this.isPaused = !this.isPaused;
    const screen = document.getElementById('pause-screen');
    if (this.isPaused) {
      screen.classList.remove('hidden');
      cancelAnimationFrame(this.requestId);
    } else {
      screen.classList.add('hidden');
      this.lastTime = performance.now();
      this.update();
    }
  }

  /* 描画関連 */
  draw() {
    // 背景
    this.context.fillStyle = '#000';
    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

    this.drawMatrix(this.context, this.arena, {x:0, y:0});
    
    // ゴースト（落下予測）描画
    this.drawGhost();

    // プレイヤー描画
    this.drawMatrix(this.context, this.player.matrix, this.player.pos);
  }

  drawGhost() {
    // プレイヤーのコピーを作成
    const ghost = {
      matrix: this.player.matrix,
      pos: { ...this.player.pos }
    };
    // 衝突するまで下げる
    while (!collide(this.arena, ghost)) {
      ghost.pos.y++;
    }
    ghost.pos.y--; // 1つ戻す

    // 薄く描画
    this.drawMatrix(this.context, ghost.matrix, ghost.pos, true);
  }

  drawNext() {
    // NEXTキャンバスクリア
    this.nextContext.fillStyle = '#000';
    this.nextContext.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
    
    // 中央に寄せる計算
    const x = (4 - this.nextPiece[0].length) / 2;
    const y = (4 - this.nextPiece.length) / 2;
    this.drawMatrix(this.nextContext, this.nextPiece, {x, y});
  }

  drawMatrix(ctx, matrix, offset, isGhost = false) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          if (isGhost) {
            // ゴーストは枠線のみ
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.1;
            ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
          } else {
            // 通常ブロック
            ctx.fillStyle = COLORS[value];
            ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
            
            // 立体感
            ctx.lineWidth = 0.05;
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);

            // ボム装飾
            if (value === 8) {
              ctx.fillStyle = 'white';
              ctx.fillRect(x + offset.x + 0.35, y + offset.y + 0.35, 0.3, 0.3);
            }
          }
        }
      });
    });
  }

  update(time = 0) {
    if (!this.isRunning || this.isPaused) return;

    const deltaTime = time - this.lastTime;
    this.lastTime = time;
    
    this.dropCounter += deltaTime;
    if (this.dropCounter > this.dropInterval) {
      this.playerDrop();
    }

    this.draw();
    this.requestId = requestAnimationFrame(this.update.bind(this));
  }
}

// ゲームインスタンス作成
const game = new Tetris();
</script>
</body>
</html>
